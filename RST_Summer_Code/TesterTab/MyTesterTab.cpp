//---------------------------------------------------------------------
//  Copyright (c) 2009 Mike Stilman
//  All Rights Reserved.
//
//  Permission to duplicate or use this software in whole or in part
//  is only granted by consultation with the author.
//
//    Mike Stilman              mstilman@cc.gatech.edu
//
//	  Robotics and Intelligent Machines
//    Georgia Tech
//--------------------------------------------------------------------

#include "MyTesterTab.h"

#include <wx/wx.h>
#include <GUI/Viewer.h>
#include <GUI/GUI.h>
#include <GUI/RSTSlider.h>
#include <GUI/RSTFrame.h>
#include <iostream>

#include <Tabs/AllTabs.h>
#include <RSTApp.h>

#include <Tools/World.h>
#include <Tools/Link.h>
#include <Tools/Object.h>
#include <Tools/Constants.h>

#include <time.h>

using namespace std;
using namespace Eigen;

const string MyTesterTab::leftArm_LastLink_name =  "LJ6";
const string MyTesterTab::robot_name = "Robina";

/* Quick intro to adding tabs:
 * 1- Copy template cpp and header files and replace with new class name
 * 2- include classname.h in AllTabs.h, and use the ADD_TAB macro to create it
 */

// Control IDs (used for event handling - be sure to start with a non-conflicted id)
enum MyTesterTabEvents {
	button_SetStart = 50,
	button_SetGoal,
        button_SetMovObj,
        button_ShowListMovObj,
        button_CheckCollisions,
	button_showStart,
	button_showGoal,
	button_free,
	button_test,
	button_Plan,
	button_Stop,
	button_UpdateTime,
	button_ExportSequence,
	button_ShowPath,
	slider_Time
};


//Add a handler for any events that can be generated by the widgets you add here (sliders, radio, checkbox, etc)
BEGIN_EVENT_TABLE( MyTesterTab, wxPanel )
EVT_COMMAND ( wxID_ANY, wxEVT_RST_SLIDER_CHANGE, MyTesterTab::OnSlider )
EVT_COMMAND ( wxID_ANY, wxEVT_COMMAND_BUTTON_CLICKED, MyTesterTab::OnButton )
END_EVENT_TABLE()

// Class constructor for the tab: Each tab will be a subclass of RSTTab
IMPLEMENT_DYNAMIC_CLASS( MyTesterTab, RSTTab )

/**
 * @function MyTesterTab
 * @brief Constructor
 */
MyTesterTab::MyTesterTab(wxWindow *parent, const wxWindowID id,
		const wxPoint& pos, const wxSize& size, long style) :

	RSTTab(parent, id, pos, size, style) {

        // sizer for whole tab
        wxBoxSizer* sizerFull;
	sizerFull = new wxBoxSizer( wxHORIZONTAL );

	// Create StaticBox container for all items
	wxStaticBox* configBox = new wxStaticBox( this, -1, wxT("For you, human user") );

	// Create sizer for this box with horizontal layout
	wxStaticBoxSizer* configBoxSizer = new wxStaticBoxSizer( configBox, wxHORIZONTAL );


	/// 1st Column: Start Settings
	wxBoxSizer *col1Sizer = new wxBoxSizer(wxVERTICAL);

	col1Sizer->Add(new wxButton(this, button_SetStart, wxT("Set &Start")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together
	col1Sizer->Add(new wxButton(this, button_showStart, wxT("Show S&tart")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together
	col1Sizer->Add(new wxButton(this, button_free, wxT("Test raw Jacob")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together


	// Add col1Sizer to the configuration box
	configBoxSizer->Add(col1Sizer,
			1, // takes half the space of the configure box
			wxALIGN_NOT); // no border and center horizontally


	/// 2nd Column: Movable Objects Settings
	wxBoxSizer *col2Sizer = new wxBoxSizer(wxVERTICAL);

	col2Sizer->Add(new wxButton(this, button_SetMovObj, wxT("Set &Movable Object")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together
	col2Sizer->Add(new wxButton(this, button_ShowListMovObj, wxT("Show List Movables")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together
	col2Sizer->Add(new wxButton(this, button_CheckCollisions, wxT("Check collisions")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together

	// Add col2Sizer to the configuration box
	configBoxSizer->Add(col2Sizer,
			1, // takes half the space of the configure box
			wxALIGN_NOT); // no border and center horizontally



	/// 3rd Column: Goal Settings
	wxBoxSizer *col3Sizer = new wxBoxSizer(wxVERTICAL);

	col3Sizer->Add(new wxButton(this, button_SetGoal, wxT("Set &Goal")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together
	col3Sizer->Add(new wxButton(this, button_showGoal, wxT("Show G&oal")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together
	col3Sizer->Add(new wxButton(this, button_test, wxT("Test JT_RRT")),
			0, // make horizontally unstretchable
			wxALL, // make border all around (implicit top alignment)
			1); // set border width to 1, so start buttons are close together
	configBoxSizer->Add(col3Sizer,
			1, // size evenly with radio box and checkboxes
			wxALIGN_NOT); // no border and center horizontally

	// Add this box to parent sizer
	sizerFull->Add( configBoxSizer,
			4, // 4-to-1 ratio with execute sizer, since it just has 3 buttons
			wxEXPAND | wxALL,
			6);


	// ** Create right static box for running the planner **
	wxStaticBox* executeBox = new wxStaticBox(this, -1, wxT("Execution"));

	// Create sizer for this box
	wxStaticBoxSizer* executeBoxSizer = new wxStaticBoxSizer(executeBox, wxVERTICAL);

	// Add buttons for "plan", "save movie", and "show path"
	executeBoxSizer->Add(new wxButton(this, button_Plan, wxT("&Start")),
			1, // stretch to fit horizontally
			wxGROW); // let it hog all the space in it's column

	executeBoxSizer->Add(new wxButton(this, button_Stop, wxT("&Stop")),
			1, // stretch to fit horizontally
			wxGROW);


	wxBoxSizer *timeSizer = new wxBoxSizer(wxHORIZONTAL);
	timeText = new wxTextCtrl(this,1008,wxT("5.0"),wxDefaultPosition,wxSize(40,20),wxTE_RIGHT);//,wxTE_PROCESS_ENTER | wxTE_RIGHT);
	timeSizer->Add(timeText,2,wxALL,1);
	timeSizer->Add(new wxButton(this, button_UpdateTime, wxT("Set T(s)")),2,wxALL,1);
	executeBoxSizer->Add(timeSizer,1,wxALL,2);

	executeBoxSizer->Add(new wxButton(this, button_ShowPath, wxT("&Print")),
			1, // stretch to fit horizontally
			wxGROW);

	sizerFull->Add(executeBoxSizer, 1, wxEXPAND | wxALL, 6);

	SetSizer(sizerFull);

	reset_all();
}

/**
 * @function init_Trans
 * @brief Initialize TWBase, Tee and T
 */
void MyTesterTab::initTrans()
{
   Eigen::Transform<double, 3, Eigen::Affine> basePose = world->robots[robot_ID]->baseLink->absPose;
   Eigen::VectorXd baseTrans = basePose.translation();


   TWBase.setIdentity();
   TWBase.rotate( AngleAxis<double>( 0*PI, Vector3d(0.0, 0.0, 1.0) ) );
   TWBase.translation()<< baseTrans(0),baseTrans(1) , baseTrans(2);

   Tee.setIdentity(); 
   Tee.translation()<< -0.070, 0.106, -0.111;
   Tee.rotate( AngleAxis<double>( PI/2.0, Vector3d(0.0, 1.0, 0.0) ) );
  
   T.setIdentity();
}

/**
 * @function getRobotID
 * @brief Get the ID of the robot (this is not that much used, but nonetheless)
 */
int MyTesterTab::getRobotID( string robotName )
{
  int robotID = world->findRobot( robotName );
  return robotID;
}

/**
 * @function get_links
 * @brief Get links from the robot in the world
 */
void MyTesterTab::getLinks()
{
  links_ID.clear();

  int lastLink_ID = world->robots[robot_ID]->findLink( leftArm_LastLink_name );

  links_ID.resize( leftArm_numLinks );
  links_ID[ leftArm_numLinks  - 1 ] = lastLink_ID;
  for(int i = leftArm_numLinks - 2; i >= 0; i--) 
    { links_ID[i] = world->robots[robot_ID]->links[links_ID[i+1]]->parent->index; }

  num_links = links_ID.size();

  EE_ID = links_ID[links_ID.size() - 1];
}

/**
 * @function get_current_config
 * @brief Get current configuration in jointspace
 */
Eigen::VectorXd MyTesterTab::getCurrentConfig()
{
  Eigen::VectorXd current_config;
  current_config.resize( num_links );

  for( int i = 0; i < num_links; i++ )
     { current_config[i] = world->robots[robot_ID]->links[links_ID[i]]->jVal; }

  return current_config;
}

/**
 * @function OnButton
 * @brief Handle Button events
 * @author Achq 
 */
void MyTesterTab::OnButton(wxCommandEvent &evt) {

        //-- Always initialize 
        getLinks();
        robot_ID = getRobotID( robot_name );
        initTrans();

	int button_num = evt.GetId();

        //-- Button Options
	switch (button_num) {

	/**< Set Start */
	case button_SetStart:
                if( world != NULL )
                  { if( world->robots.size() < 1 )
                      { printf("No robot in the loaded world, you need one! \n"); break; }
                    
                    cout<<"** Setting start jointspace configuration **"<<endl;

                    startConfig.resize( num_links );
                    for( int i = 0; i < num_links; i++ )
                       { startConfig[i] = world->robots[robot_ID]->links[links_ID[i]]->jVal;
                         cout<<startConfig[i]<<" ";
                       }
                    cout<<endl;
                  } 
                else
                 { cout<<"No world loaded, I cannot set a goal \n"<<endl;}

		break;

	/**< Set Goal */
	case button_SetGoal:
		if( world != NULL )
                  { if( robot_ID < 0 )
                      { printf("No robot in the loaded world, you need one! \n"); break; }

                    if( selectedObject != NULL )
                      { 
                        target_ID = world->findObject( selectedObject->name );
			goal_pose.setIdentity();
                        goal_pose = selectedObject->absPose; 
                        goal_position.resize(3);
                        goal_position = goal_pose.translation();
                        goal_name = selectedObject->name;

                        cout<<"** The goal is: "<<goal_name<<" with position: "<<endl;
                        cout<<goal_position<<endl;
                      }
                    else
                      { cout<<"Please, select an object in the Viewer Tree and try again"<<endl; }                    
                   }
                else
                   { cout<<"No world loaded, I cannot set a goal"<<endl; } 
		break;

        /**< Set Movable Object */
        case button_SetMovObj:
		if( world != NULL )
                  { if( world->robots.size() < 1 )
                      { printf("No robot in the loaded world, you need one! \n"); break; }

                    if( selectedObject != NULL )
                      { 
                        int id = world->findObject( selectedObject->name );
                        bool is_movable = false;

                        /* Check if it is already set as movable object */ 
                        for( int i = 0; i < movableObjects.size(); i++ )
                           {
                             if( movableObjects[i] == id )
                                { cout<<"Already movable"<<endl; is_movable = true; break; }
                           }
                        /* If it is not movable yet, let's make it movable */
                        if( is_movable == false )
                          { movableObjects.push_back( id ); 
                            cout<<"** Movable Object: "<<world->objects[id]->name<<endl;
                          }
                      }
                    else
                      { cout<<"Please, select an object in the Viewer Tree and try again"<<endl; }                    
                   }
                else
                   { cout<<"No world loaded"<<endl; } 
		break;
		
        /**< Show List of Movable Objects */
        case button_ShowListMovObj:

                cout<<"** Number of Movable Objects registered:"<<movableObjects.size()<<endl;

		for( int i = 0; i < movableObjects.size(); i++ )
                   {
                     cout<<"["<<i<<"] "<<world->objects[ movableObjects[i] ]->name<<endl;
                   } 
		break;        
        /**< Tell you if there are any collisions */
        case button_CheckCollisions:
              {   
	       world->updateAllCollisionModels();
               if( world->checkCollisions() == false )
                 { cout<<"** No Collisions detected "<<endl; }
               else
                 { cout<<"** Collisions detected"<<endl; }
              } 
               break; 

	/**< Show Start */
	case button_showStart:
	      {
                if( startConfig.size() < 1 )
                  { cout<<"You have not set a Start configuration yet"<<endl; break; }   

                Eigen::Transform<double, 3, Eigen::Affine> Tw;
                robinaLeftArm_fk( startConfig, TWBase, Tee, Tw ); 
                std::cout << "Start Position: " << Tw.translation() << endl;

                world->robots[robot_ID]->setConf( links_ID, startConfig ); 
                viewer->UpdateCamera();
              }
		break;

	/**< Show Goal */
	case button_showGoal:

                if( goal_position.size() < 1 )
                  { cout<<"You have not set a Goal position yet"<<endl; break; }

                cout<<" * The goal object is: "<<goal_name<<" and its location is:"<<endl<<goal_position<<endl;                

		break;


	/**< Testing goWSPos */   
	case button_free:
               { vector<Eigen::VectorXd> path;

                 goWSOrient a;  
                 a.initialize( world, robot_ID, links_ID, TWBase, Tee );
                 bool result = a.balancePath( startConfig, goal_pose, path );
                 /*
                 goWSOrient a;  
                 a.initialize( world, robot_ID, links_ID, TWBase, Tee );
                 bool result = a.straightPath( startConfig, goal_pose, path );
                 */
                 if( result == true )
                   { SetTimeline( robot_ID, links_ID, path ); }                 
               } 
		break;

        /**< JT_RRT */
	case button_test:
               {
                 Eigen::Transform<double, 3, Eigen::Affine> T;
                 robinaLeftArm_fk( getCurrentConfig(), TWBase, Tee, T );
                 cout<<"Translation of last link: " << T.translation().transpose()<<endl;

                 vector<Eigen::VectorXd> path;
                 JG_RRT a;
                 a.initialize( world, robot_ID, links_ID, TWBase, Tee );
                 std::vector< Eigen::VectorXd > b_path; b_path.resize(0);
                 bool result = a.plan( startConfig, goal_pose, b_path, path );


                 if( result == true )
                 {
                     FILE * pFile; 
                     pFile = fopen( "JTRRT_BEFORE.txt", "w" );
                     int num = path[0].size(); 
                     for ( int n=0 ; n< path.size(); n++ )
                      {  fprintf( pFile, " %d ", n );
                         for( int i = 0; i < num; i++ )
                         { fprintf (pFile, " %.3f ", path[n](i) ); }

                         world->robots[robot_ID]->setConf(links_ID, path[n] );
                         Eigen::VectorXd pos = world->robots[robot_ID]->links[ links_ID[ links_ID.size() - 1 ] ]->absPose.translation(); 
                         fprintf( pFile, " %.3f %.3f %.3f \n ", pos(0), pos(1), pos(2) );
                      }
		     fclose( pFile ); 

                 }
                 a.smoothPath( path );

                 if( result == true )
                 {
                     SetTimeline( robot_ID, links_ID, path ); 
                     FILE * pFile; 
                     pFile = fopen( "JTRRT_AFTER.txt", "w" );
                     int num = path[0].size(); 
                     for ( int n=0 ; n< path.size(); n++ )
                      {  fprintf( pFile, " %d ", n );
                         for( int i = 0; i < num; i++ )
                         { fprintf (pFile, " %.3f ", path[n](i) ); }

                         world->robots[robot_ID]->setConf(links_ID, path[n] );
                         Eigen::VectorXd pos = world->robots[robot_ID]->links[ links_ID[ links_ID.size() - 1 ] ]->absPose.translation(); 
                         fprintf( pFile, " %.3f %.3f %.3f \n ", pos(0), pos(1), pos(2) );
                      }
		     fclose( pFile ); 

                 }

/*
                 vector<Eigen::VectorXd> spath;

                 double maxVelArray[7] = { 1.309, 1.6406, 3.2812, 2.618, 5.236, 3.4907, 3.4907 };   
                 double maxAcelArray[7] = { 45.379, 45.397, 85.521, 101.229, 228.638, 153.589, 76.794 };
                 ParSmoother ps( world, robot_ID, links_ID, 0.025 );
                 spath = ps.smoothPath( maxVelArray, maxAcelArray, 1000, 0.001, path );

 */                   
               } 
		break;

	/**< Plan, call the path planner */
	case button_Plan:
               {   
                /*              
                Planner1 p1;
                std::vector<Eigen::VectorXd> path;

                p1.initialize( *world,robot_ID, links_ID, TWBase, Tee );  
                bool result = p1.findPath( startConfig, goal_position, path );
                */   

                MyTesterPlanner p1;
                std::vector<Eigen::VectorXd> path;

                p1.initialize( *world,robot_ID, links_ID, TWBase, Tee );  
                bool result = p1.findPath( startConfig, goal_position, path );

                if( result == true )
                  { SetTimeline( robot_ID, links_ID, path ); }
                
               }
		break;


	/**< ShowPath: Print */
	case button_ShowPath:
                printf("Implement me honey \n"); 
     
		break;

	} 
}


/**
 * @function SetTimeline
 * @brief Set Timeline slider to show the plan
 */
void MyTesterTab::SetTimeline(int robot, vector<int> links, vector<Eigen::VectorXd> path){
  if( world == NULL || path.size() == 0){
      cout << "Must create a valid plan before updating its duration." << endl;
      return;
     }

  double T;
  timeText->GetValue().ToDouble(&T);

  int numsteps = path.size();
  double increment = T/(double)numsteps;

  cout << "Updating Timeline - Increment: " << increment << " Total T: " << T << " Steps: " << numsteps << endl;

  frame->InitTimer(string("My_Plan"),increment);

  for( int i = 0; i <path.size(); i++ ) 
     { 
       world->robots[robot_ID]->setConf( links_ID, path[i] ); 
       frame->AddWorld(world);
     }

}

/**
 */
void MyTesterTab::SetTimeline(int robot, vector<int> links, list<Eigen::VectorXd> path){
		if(world == NULL ||  path.size() == 0){
			cout << "Must create a valid plan before updating its duration." << endl;
			return;
		}

		double T;
		timeText->GetValue().ToDouble(&T);

		int numsteps = path.size();
		double increment = T/(double)numsteps;

		cout << "Updating Timeline - Increment: " << increment << " Total T: " << T << " Steps: " << numsteps << endl;

		frame->InitTimer(string("RRT_Plan"),increment);

		for(list<VectorXd>::iterator it = path.begin(); it != path.end(); it++) {
			world->robots[robot]->setConf(links, *it);
            frame->AddWorld(world);
		}
}


/**
 * @function OnSlider
 * @brief Handle slider changes
 */
void MyTesterTab::OnSlider(wxCommandEvent &evt) {
	if (selectedTreeNode == NULL) {
		return;
	}

	int slnum = evt.GetId();
	double pos = *(double*) evt.GetClientData();
	char numBuf[1000];

	switch (slnum) {
	case slider_Time:
		sprintf(numBuf, "X Change: %7.4f", pos);
		cout << "Timeline slider output: " << numBuf << endl;
		//handleTimeSlider(); // uses slider position to query plan state
		break;

	default:
		return;
	}
	//world->updateCollision(o);
	//viewer->UpdateCamera();

	if (frame != NULL)
		frame->SetStatusText(wxString(numBuf, wxConvUTF8));
}

//void MyTesterTab::OnButton(wxCommandEvent &evt) {
// This function is called when an object is selected in the Tree View or other
// global changes to the RST world. Use this to capture events from outside the tab.
void MyTesterTab::RSTStateChange() {

	if (selectedTreeNode == NULL) {
		return;
	}
	string statusBuf;
	string buf, buf2;

	switch (selectedTreeNode->dType) {

	case Return_Type_Object:
		selectedObject = (Object*) (selectedTreeNode->data);
		statusBuf = " Selected Object: " + selectedObject->name;
		buf = "You clicked on object: " + selectedObject->name;
		// Enter action for object select events here:

		break;
	case Return_Type_Robot:
		selectedRobot = (Robot*) (selectedTreeNode->data);
		statusBuf = " Selected Robot: " + selectedRobot->name;
		buf = "You clicked on robot: " + selectedRobot->name;
		// Enter action for Robot select events here:

		break;
	case Return_Type_Link:
		selectedLink = (Link*) (selectedTreeNode->data);
		statusBuf = " Selected Link: " + selectedLink->name + " of Robot: "
				+ selectedLink->robot->name;
		buf = " Link: " + selectedLink->name + " of Robot: " + selectedLink->robot->name;

		// Enter action for link select events here:

		break;
    default:
        printf( "Someone else's problem!\n" );
        assert(0);
        exit(1);
	}
	//cout << buf << endl;
	frame->SetStatusText(wxString(statusBuf.c_str(), wxConvUTF8));
	//sizerFull->Layout();
}

/**
 * @function reset_all
 * @brief Take the trash out
 */
void MyTesterTab::reset_all()
{
  movableObjects.clear();
}
