/*
 * Copyright (c) 2011, Georgia Tech Research Corporation
 * All rights reserved.
 *
 * Humanoid Robotics Lab      Georgia Institute of Technology
 * Director: Mike Stilman     http://www.golems.org
 */

#include "JacobianTests.h"

#include <wx/wx.h>
#include <GUI/Viewer.h>
#include <GUI/GUI.h>
#include <GUI/GRIPSlider.h>
#include <GUI/GRIPFrame.h>
#include <Tabs/GRIPTab.h>

#include <iostream>

#include <Tabs/AllTabs.h>
#include <GRIPApp.h>

using namespace std;

/* Quick intro to adding tabs:
 * 1- Copy template cpp and header files and replace with new class name
 * 2- include classname.h in AllTabs.h, and use the ADD_TAB macro to create it
 */

// Control IDs (used for event handling - be sure to start with a non-conflicted id)
enum JacobianTestsEvents {
	button_SetStartConf = 50,
	button_ShowStartConf,

    button_Plot1,
	button_Plot2,
	button_Plot3,

	button_Plan,
	button_Stop,
	button_UpdateTime,
	button_ExportSequence,
	button_ShowPath,
	slider_Time,

    checkbox_FixXYZ,
    checkbox_FixOrient
};

enum SliderNames{
	SLIDER_NULLSPACE = 1000,
};

// sizer for whole tab
wxBoxSizer* sizerFull;

//Add a handler for any events that can be generated by the widgets you add here (sliders, radio, checkbox, etc)
BEGIN_EVENT_TABLE( JacobianTests, wxPanel )
EVT_COMMAND ( wxID_ANY, wxEVT_GRIP_SLIDER_CHANGE, JacobianTests::OnSlider )
EVT_COMMAND ( wxID_ANY, wxEVT_COMMAND_BUTTON_CLICKED, JacobianTests::OnButton )
EVT_COMMAND ( wxID_ANY, wxEVT_COMMAND_CHECKBOX_CLICKED, JacobianTests::OnCheckBox )
EVT_COMMAND( wxID_ANY, wxEVT_COMMAND_RADIOBOX_SELECTED, JacobianTests::OnRadio )
END_EVENT_TABLE()

// Class constructor for the tab: Each tab will be a subclass of RSTTab
IMPLEMENT_DYNAMIC_CLASS( JacobianTests, GRIPTab )

/**
 * @function JacobianTests
 * @brief Constructor
 */
JacobianTests::JacobianTests( wxWindow *parent, const wxWindowID id,
		                      const wxPoint& pos, const wxSize& size, long style) :
	                          GRIPTab(parent, id, pos, size, style ) {

    startConf.resize(0);
    targetConf.resize(0);
    targetPose.resize(0);

    robotId = 0;
    links.resize(0);

    sizerFull = new wxBoxSizer( wxHORIZONTAL );
 
    // ** Create left static box for configuring the planner **

    // Create StaticBox container for all items
    wxStaticBox* configureBox = new wxStaticBox(this, -1, wxT("Configure"));

    // Create sizer for this box with horizontal layout
    wxStaticBoxSizer* configureBoxSizer = new wxStaticBoxSizer(configureBox, wxHORIZONTAL);

    // Create sizer for start buttons in 1st column
    wxBoxSizer *col1Sizer = new wxBoxSizer(wxVERTICAL);
    col1Sizer->Add( new wxButton(this, button_SetStartConf, wxT("Set &Start Conf")),
		    0, // make horizontally unstretchable
		    wxALL, // make border all around (implicit top alignment)
		    1 ); // set border width to 1, so start buttons are close together
    col1Sizer->Add( new wxButton(this, button_ShowStartConf, wxT("Show S&tart Conf")),
		    0, // make horizontally unstretchable
		    wxALL, // make border all around (implicit top alignment)
		    1 ); // set border width to 1, so start buttons are close together

    wxBoxSizer *miniSizer1 = new wxBoxSizer(wxVERTICAL);
    miniSizer1->Add( new wxCheckBox(this, checkbox_FixXYZ, _T("Fix XYZ")),
		    1, // vertical stretch evenly
		    wxALIGN_NOT,
		    0);
    miniSizer1->Add( new wxCheckBox(this, checkbox_FixOrient, _T("Fix Orient")),
		    1, // vertical stretch evenly
		    wxALIGN_NOT,
		    0 );
    col1Sizer->Add( miniSizer1, 1, wxALIGN_NOT, 0 );

    mSlider_Nullspace = new GRIPSlider("Ang",-3,3,500,0,100,500,this, SLIDER_NULLSPACE );
    col1Sizer->Add( mSlider_Nullspace, 1, wxEXPAND | wxALL, 6 );

    // Add col1Sizer to the configuration box
    configureBoxSizer->Add( col1Sizer,
			    1, // takes half the space of the configure box
			    wxALIGN_NOT ); // no border and center horizontally

    // Create sizer for planner buttons in 4th column
    wxBoxSizer *col4Sizer = new wxBoxSizer(wxVERTICAL);
    col4Sizer->Add( new wxButton(this, button_Plot1, wxT("Plot 1")),
		    0, // make horizontally unstretchable
		    wxALL, // make border all around (implicit top alignment)
		    1 ); // set border width to 1, so start buttons are close together

    col4Sizer->Add( new wxButton(this, button_Plot2, wxT("Plot 2")),
		    0, // make horizontally unstretchable
		    wxALL, // make border all around (implicit top alignment)
		    1 ); // set border width to 1, so start buttons are close together
    col4Sizer->Add( new wxButton(this, button_Plot3, wxT("Plot 3")),
		    0, // make horizontally unstretchable
		    wxALL, // make border all around (implicit top alignment)
		    1 ); // set border width to 1, so start buttons are close together

    // Add col2Sizer to the configuration box
    configureBoxSizer->Add( col4Sizer,
			    1, // size evenly with radio box and checkboxes
			    wxALIGN_NOT ); // no border and center horizontally

    // Add this box to parent sizer
    sizerFull->Add( configureBoxSizer,
		    4, // 4-to-1 ratio with execute sizer, since it has 4 buttons
		    wxEXPAND | wxALL,
		    6 );

    // ** Create right static box for running the planner **
    wxStaticBox* executeBox = new wxStaticBox(this, -1, wxT("Execute Planner"));

    // Create sizer for this box
    wxStaticBoxSizer* executeBoxSizer = new wxStaticBoxSizer(executeBox, wxVERTICAL);

    // Add buttons for "plan", "save movie", and "show path"
    executeBoxSizer->Add( new wxButton(this, button_Plan, wxT("&Run")),
	 		  1, // stretch to fit horizontally
			  wxGROW ); // let it hog all the space in it's column

    executeBoxSizer->Add( new wxButton(this, button_Stop, wxT("&Stop")),
			  1, // stretch to fit horizontally
			  wxGROW );


    wxBoxSizer *timeSizer = new wxBoxSizer(wxHORIZONTAL);
    timeText = new wxTextCtrl(this,1008,wxT("5.0"),wxDefaultPosition,wxSize(40,20),wxTE_RIGHT);//,wxTE_PROCESS_ENTER | wxTE_RIGHT);
    timeSizer->Add(timeText,2,wxALL,1);
    timeSizer->Add(new wxButton(this, button_UpdateTime, wxT("Set T(s)")),2,wxALL,1);
    executeBoxSizer->Add(timeSizer,1,wxALL,2);

    executeBoxSizer->Add( new wxButton(this, button_ShowPath, wxT("&Print")),
			  1, // stretch to fit horizontally
			  wxGROW );

    sizerFull->Add(executeBoxSizer, 1, wxEXPAND | wxALL, 6);

    SetSizer(sizerFull);

}

/**
 * @function getLeftArmIds
 * @brief Get DOF's IDs for ROBINA's left arm
 */
Eigen::VectorXi JacobianTests::GetLeftArmIds() {

  string LINK_NAMES[7] = {"LJ0", "LJ1", "LJ2", "LJ3", "LJ4", "LJ5", "LJ6" };
   
  Eigen::VectorXi linksAll = mWorld->mRobots[robotId]->getQuickDofsIndices(); 

  Eigen::VectorXi linksLeftArm(7);
  for( unsigned int i = 0; i < 7; i++ ) {
      for( unsigned int j = 0; j < linksAll.size(); j++ ) {      
          if( mWorld->mRobots[robotId]->getDof( linksAll[j] )->getJoint()->getChildNode()->getName() == LINK_NAMES[i] ) {
              linksLeftArm[i] = linksAll[j]; 
              break;   
          }
      }
  }
  
  return linksLeftArm;
}

/**
 * @function setTimeLine
 * @brief 
 */
void JacobianTests::SetTimeline( std::list<Eigen::VectorXd> _path ) {
    
    if( mWorld == NULL || _path.size() == 0 ) {
        std::cout << "--(!) Must create a valid plan before updating its duration (!)--" << std::endl;
	      return;
    }
    
    double T;
    timeText->GetValue().ToDouble(&T);
    
    int numsteps = _path.size();
    double increment = T/(double)numsteps;

    cout << "-->(+) Updating Timeline - Increment: " << increment << " Total T: " << T << " Steps: " << numsteps << endl;

    frame->InitTimer( string("RRT_Plan"),increment );

    Eigen::VectorXd vals( links.size() );

    for( std::list<Eigen::VectorXd>::iterator it = _path.begin(); it != _path.end(); it++ ) {

        mWorld->mRobots[robotId]->setDofs( *it, links );
	      mWorld->mRobots[robotId]->update();

        frame->AddWorld( mWorld );
    }
   
}


/**
 * @function OnButton
 * @brief Handle Button Events
 */
void JacobianTests::OnButton(wxCommandEvent &evt) {

    int button_num = evt.GetId();
    links = GetLeftArmIds();

    switch (button_num) {

        /** Set Start Configuration */
        case button_SetStartConf:
	          if ( mWorld != NULL ) {
	              if( mWorld->mRobots.size() < 1) {
            	      cout << "--(!) Must have a world with a robot to set a Start state (!)--" << endl;
		                break;
		            }
		            std::cout << "--(i) Setting Start state for " << mWorld->mRobots[robotId]->getName() << ":" << std::endl;
                
                startConf = mWorld->mRobots[robotId]->getDofs( links );

		            for( unsigned int i = 0; i < startConf.size(); i++ )
                {  std::cout << startConf(i) << " ";  } 
		            std::cout << endl;
	          } else {
	              std::cout << "--(!) Must have a world loaded to set a Start state.(!)--" << std::endl;
	          }
	          break;


        /** Show Start */
	      case button_ShowStartConf:

	          if( startConf.size() < 1 ) {
	              std::cout << "--(x) First, set a start configuration (x)--" << std::endl;
		            break;
	          } 

            mWorld->mRobots[robotId]->setDofs( startConf, links );

	          for( unsigned int i = 0; i< startConf.size(); i++ )
            {  cout << startConf(i) << " "; }
	          std::cout << std::endl;

	          mWorld->mRobots[robotId]->update();
	          viewer->UpdateCamera();
 
      	    break;


        /** Execute Plan */
	      case button_Plan:
          {         
             printf("Here we don't plan yet \n");
          }
	          break;

        /** Plot 1 */
	      case button_Plot1:
          {
          }		
	          break;

        /** Plot 2 */
	      case button_Plot2:
          {

          }		
	          break;

        /** Plot 3 */
	      case button_Plot3:
          {

          }		
	          break;

        

        /** UpdateTime (?) */
	      case button_UpdateTime:
          {
	          /// Update the time span of the movie timeline
	          //SetTimeline();
          }		
	          break;

        /** Show Path */
	      case button_ShowPath:            
	          if( mWorld == NULL ) {
	              cout << "--(!) Must create a valid plan before printing. (!)--" << endl;
		            return;
	          } else {
                printf("--(i) Printing (i)-- \n");
            }        
	          break;

    } // end of switch
}

/**
 * @function NullspaceTest
 */
double JacobianTests::NullspaceTest( double _ang ) {

  kinematics::BodyNode *mEENode;
  int mEEId;
  mEENode = mWorld->mRobots[robotId]->getNode( "LJ6" );
  mEEId = mEENode->getSkelIndex();

  // Set to start configuration
  mWorld->mRobots[robotId]->setDofs( startConf, links );
  mWorld->mRobots[robotId]->update();

  // Get current XYZ position
  Eigen::MatrixXd transStart = mEENode->getWorldTransform();
  Eigen::Vector3d ts; ts << transStart(0,3), transStart(1,3), transStart(2,3);

  Eigen::MatrixXd Jaclin;
  Jaclin = mEENode->getJacobianLinear().topRightCorner( 3, links.size() );


  // Projecting in nullspace
  Eigen::MatrixXd Id( links.size(), links.size() );
  Id.setIdentity();

  Eigen::VectorXd alpha( links.size() );  
  for( int i = 0; i < alpha.size(); i++ ) {
     alpha[i] = _ang;
  }

  Eigen::VectorXd dq( links.size() );
  dq = ( Id - Jaclin.transpose()*(Jaclin*Jaclin.transpose()).inverse()*Jaclin )*alpha;

  std::cout << "dq: " << dq.transpose() << std::endl;
  Eigen::VectorXd newConfig = startConf + dq;

  mWorld->mRobots[robotId]->setDofs( newConfig, links );
  mWorld->mRobots[robotId]->update();

  // Get current XYZ position
  Eigen::MatrixXd transEnd = mEENode->getWorldTransform();
  Eigen::Vector3d te; te << transEnd(0,3), transEnd(1,3), transEnd(2,3);

  viewer->UpdateCamera();

  printf("Alpha element: %f \n", _ang);

  
  return (ts-te).norm();
}

/**
 * @function OnSlider
 * @brief Handle slider changes
 */
void JacobianTests::OnSlider(wxCommandEvent &evt) {

    /*
    if ( selectedTreeNode == NULL ) {
        return;
    } */ /// Do I need this now? - AHQ: Dec 6th, 2012

    int slnum = evt.GetId();
    double pos = *(double*) evt.GetClientData();
    char numBuf[1000];

    switch (slnum) {

        case slider_Time:
	          sprintf(numBuf, "X Change: %7.4f", pos);
	          std::cout << "-->(i) Timeline slider output: " << numBuf << std::endl;
	          //handleTimeSlider(); // uses slider position to query plan state
	          break;

        case SLIDER_NULLSPACE:
             {
              double diff3D = NullspaceTest( pos );
              printf("3D error: %f \n", diff3D );
             }
	          break;

      	default:
	          return;
    }

    //world->updateCollision(o);
    //viewer->UpdateCamera();

    if (frame != NULL)
        frame->SetStatusText(wxString(numBuf, wxConvUTF8));
}

/**
 * @function OnRadio
 */
void JacobianTests::OnRadio( wxCommandEvent &evt ) {
   
}

/**
 * @function OnCheckBox
 */
void JacobianTests::OnCheckBox( wxCommandEvent &evt ) {

    int checkbox_num = evt.GetId();

    switch ( checkbox_num ) {
        
    case checkbox_FixXYZ:
        mFixXYZ = (bool)evt.GetSelection();
	    std::cout << "--> Fixing XYZ Position: "<< mFixXYZ << std::endl;
	    break;

	case checkbox_FixOrient:
	    mFixOrient = (bool)evt.GetSelection();
	    std::cout << "--> Fixing Orientation: "<< mFixOrient << std::endl;
	    break;
    }

}

/**
 * @function GRIPStateChange -- Keep using this name as it is a virtual function
 * @brief This function is called when an object is selected in the Tree View or other
 *        global changes to the RST world. Use this to capture events from outside the tab.
 */
void JacobianTests::GRIPStateChange() {
    if ( selectedTreeNode == NULL ) {

        return;
    }

    string statusBuf;
    string buf, buf2;

    switch (selectedTreeNode->dType) {

        case Return_Type_Object:
	          selectedObject = (planning::Object*) ( selectedTreeNode->data );
	          statusBuf = " Selected Object: " + selectedObject->getName();
	          buf = "You clicked on object: " + selectedObject->getName();
	          // Enter action for object select events here:
	          break;

	      case Return_Type_Robot:
	          selectedRobot = (planning::Robot*) ( selectedTreeNode->data );
	          statusBuf = " Selected Robot: " + selectedRobot->getName();
	          buf = " You clicked on robot: " + selectedRobot->getName();
      	    // Enter action for Robot select events here:
	          break;
	      case Return_Type_Node:
	          selectedNode = (kinematics::BodyNode*) ( selectedTreeNode->data );
	          statusBuf = " Selected Body Node: " + string(selectedNode->getName()) + " of Robot: "
			      + ( (planning::Robot*) selectedNode->getSkel() )->getName();
	          buf = " Node: " + string(selectedNode->getName()) + " of Robot: " + ( (planning::Robot*) selectedNode->getSkel() )->getName();
	          // Enter action for link select events here:
      	    break;
        default:
            fprintf(stderr, "--( :D ) Someone else's problem!\n");
            assert(0);
            exit(1);
    }

    //cout << buf << endl;
    frame->SetStatusText(wxString(statusBuf.c_str(), wxConvUTF8));
    sizerFull->Layout();
}
